# 设计模式

## 工厂模式

```php
<?php

/**
 * 工厂模式
 * 说明：工厂模式顾名思义，就是批量生成对象
 * 优点：由统一方法生成对象，如果以后类需要改名，可以只修改一处就完成，而不需要整个项目修改；
 * 备注：这里只是实现简单的样例，实际中还需要考虑依赖注入的实现
 */

//批量产品类
class Product
{
    public function Say()
    {
        echo "I am a product!";
    }
}

//批量生成的工厂
class Factory
{

    public static function CreateObject($className)
    {
        //这里只是实例，真实项目$className中还需要命名空间，以及依赖注入配合
        return new $className;
    }
}

$product = Factory::CreateObject('Product');
$product->say();

```

## 适配器模式

```php
<?php
/**
 * 适配器模式
 * 说明：适配器模式将截然不同的函数接口封装成统一个API
 * 优点：避免资源浪费。
 * 示例：php的数据库操作有mysql、mysqli、pdo 共3种，可以用数据库统一成一致。
 * 类似的场景还有cache适配器，将memcache、redis、file、apc等不同的缓存函数统一成
 * 一致的接口。
 */


/**
 * 接口统一规范，适配器模式主要体现在规范
 */
interface IDatabase{
    /**
     * 存储连接
     * @var $conn
     */
    protected $conn;

    function connect($host,$user,$passwd,$dbname);
    function query($sql);
    function close();
}

/**
 * MySQL连接
 */
/**
* 
*/
class MySQL implements IDatabase
{
    protected $conn;
    function connect($host,$user,$passwd,$dbname)
    {
        $conn = mysql_connect($host,$user,$passwd);
        mysql_select_db($dbname,$conn);
        $this->conn = $conn;
    }

    function query($sql)
    {
        $res = mysql_query($sql,$this->conn);
        return $res;
    }

    function close()
    {
        mysql_close($this->conn);
    }
}

/**
 * MySQLi连接
 */
/**
* 
*/
class MySQLi implements IDatabase
{
    protected $conn;
    function connect($host,$user,$passwd,$dbname)
    {
        $conn = mysqli_connect($host,$user,$passwd,$dbname);
        $this->conn = $conn;
    }

    function query($sql)
    {
        $res = mysqli_query($this->conn,$sql);
        return $res;
    }

    function close()
    {
        mysqli_close($this->conn);
    }
}

/**
 * PDO连接
 */
/**
* 
*/
class MyPDO implements IDatabase
{
    protected $conn;
    function connect($host,$user,$passwd,$dbname)
    {
        $conn = new PDO("mysql:host=$host;dbname=$dbname",$user,$passwd);
        $this->conn = $conn;
    }

    function query($sql)
    {
        return $this->conn->query($sql);
    }

    function close()
    {
        unset($this->conn);
    }
}

//使用
$db = new MySQL();//这里可以换成MySQLi()或者MyPDO()，这就是适配器
$db->connect('127.0.0.1','root','root','test');
$db->query('show databases');
$db->close();


```

## 外观模式

```php
<?php

/**
 * 参考：<https://www.cnblogs.com/V1haoge/p/6484128.html>
 * 外观模式：用于请求与子系统，那么将各个子系统进行封装为一个大系统，大系统统一对接请求
 */
class Part01
{
    public function show()
    {
        echo "I am header\n\r";
    }
}

class Part02
{
    public function show()
    {
        echo "I am body\n\r";
    }
}

class Part03
{
    public function show()
    {
        echo "I am footer\n\r";
    }
}

class Human
{
    public function show()
    {
        (new Part01)->show();
        (new Part02)->show();
        (new Part03)->show();
    }
}

(new Human())->show();

```

## 桥接模式

```php
<?php

/**
 * 参考：<https://www.cnblogs.com/V1haoge/p/6497919.html>
 * 桥接模式：将多对多连接解耦代码，一般应用于连接数据库
 */
// 目的地接口
interface Brige
{
    public function arrive();
}

// 来源地接口
abstract class Source
{
    public $brige = null;

    public function __construct($dest)
    {
        $this->brige = $dest;
    }

    abstract public function from();
}

// 设置目的地01
class Dest01 implements Brige
{
    public function arrive()
    {
        echo("I want arrive to Dest01\n\r");
    }
}

// 设置目的地02
class Dest02 implements Brige
{
    public function arrive()
    {
        echo("I want arrive to Dest02\n\r");
    }
}

// 设置来源地01
class Sour01 extends Source
{
    public function from()
    {
        echo("I am from Sour01\n\r");
    }
}

// 设置来源地02
class Sour02 extends Source
{
    public function from()
    {
        echo("I am from Sour02\n\r");
    }
}

$source = new Sour01(new Dest02);// 由配置获取对应的类
$source->from();
$source->brige->arrive();


```

## 装饰器模式

```php
<?php
/**
 * 装饰器模式
 * 说明：可以动态的添加修改类的功能；
 *      装饰器是继承功能的补充，继承是一个父类，多个子类；装饰器可以一个装饰类，多个基类（类似父类那种感觉，虽然不是继承）
 * 思想：通过将基类实例注入装饰类，装饰类可以进行功能扩展；当然还可以切换不同的基类实例
 * 功能：能实现效果的叠加
 *
 *
①优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，
 装饰模式可以动态扩展一个实现类的功能。例如：类A有个incr()方法，方法作用是在数字上+1，
 * 类B对类A的incr()进行装饰，需要在数字上+1+1，即+2；
 此时，又有一个类A2有incr()方法，作用是在数字上+10，此时仍然需要在类A2的incr()方法基础上+1，
 * 此时，如果采用的是继承，就得重写一个类B2，
 但是装饰模式，可以直接将类A2注入类B，即可完成功能实现

②缺点：多层装饰比较复杂。

③使用场景：1、扩展一个类的功能。 2、动态增加功能，动态撤销。
 */

//定义原始功能抽象类
abstract class Tile
{
	//获取健康因子功能
	abstract function getWealthFactor();
}

//实现原始功能类
class Plains extends Tile
{
	private $wealthfactor = 2;
	function getWealthFactor()
	{
		return $this->wealthfactor;
	}
}

//定义装饰类
abstract class TileDecorator extends Tile
{
	protected $tile;	#存储Tile实例
	function __construct(Tile $tile)
	{
		$this->tile = $tile;
	}
}

//具体实现类，都是继承于装饰类，而实现原始功能类作为基础功能，被装饰类包裹
class DiamondDecorator extends TileDecorator
{
	function getWealthFactor()
	{
		return $this->tile->getWealthFactor()+2;
	}
	
}

class PollutionDecorator extends TileDecorator
{
	function getWealthFactor()
	{
		return $this->tile->getWealthFactor()-4;
	}
	
}

// 测试
$tile = new Plains;
var_dump($tile->getWealthFactor());#返回 	2

//将plains实例作为形参实例化DiamondDecorator，形成了效果叠加
$tile = new DiamondDecorator(new plains);
var_dump($tile->getWealthFactor());#返回 	4

//将DiamondDecorator实例作为形参实例化PollutionDecorator，进一步形成了效果叠加
$tile = new PollutionDecorator(new DiamondDecorator(new plains));
var_dump($tile->getWealthFactor());#返回 	0

```

## 原型模式

```php
<?php
/**
 * 原型模式
 * 说明：
 * 1、与工厂模式作用类似，都是用来创建对象。
 * 2、与工厂模式的实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建
 *    新的对象。这样就免去了类创建时的重复初始化操作
 * 示例：原型模式适用于大对象的创建。创建一个大对象需要很大的开销，如果每次new就会消耗
 * 很大，原型模式仅需要内存拷贝即可(其实就是用关键字clone)
 */
class BigObject
{
    protected $data = 0;

    function __construct($data)
    {
//        echo "消耗大量资源";
        $this->data = $data;
    }

    public function getData()
    {
        echo $this->data."\n";
    }

    public function __clone()
    {
        $this->data = 0;
    }
}

$bigOne = new BigObject(1);    //创建大对象
$bigOne->getData();
$bigTwo = clone $bigOne;
$bigTwo->getData();
//结果：
// 消耗大量资源               #说明：clone关键字复制对象，不会再调用__construct()初始化
// 1
// 0                          #clone默认是将对象所有数据都复制，包括类属性值，如果不需要
                              #复制，则需要在__clone()魔术方法中定义；如例所示


```

## 解释器模式

```php
<?php
/**
 * 解释器：
 */
// 所有表达式的基类，包括变量、字符以及运算符
abstract class Expression
{
    private static $keycount = 0;     #所有子类共享的，默认作为键值对的键
    private $key;                   #存储键值对的键，以便后面能在Context::expressionstore数组中获取到对应值

    abstract function interpret(Context $context);    #解释器方法

    function getKey()
    {
        if (!isset($this->key)) {
            self::$keycount++;      #返回以后的键值+1；
            $this->key = self::$keycount;
        }
        return $this->key;
    }
}

//字符表达式
class LiteralExpression extends Expression
{
    private $value;

    function __construct($value)
    {
        $this->value = $value;
    }

    function interpret(Context $context)
    {
        $context->replace($this, $this->value);   #其实是存储键值对的一个功能
    }
}

//上下文类，起到一个储存和显示键值对的作用，存储的是变量类似于键和值，而运算符就表示键和运算结果
class Context
{
    private $expressionstore = array(); #存储键值数组

    //存入self::expressionstore数组的方法
    function replace(Expression $exp, $value)
    {
        $this->expressionstore[$exp->getKey()] = $value;
    }

    //获取具体值的方法
    function lookup(Expression $exp)
    {
        return $this->expressionstore[$exp->getKey()];
    }
}

class VariableExpression extends Expression
{
    private $name;
    private $val;

    function __construct($name, $val = null)
    {
        $this->name = $name;
        $this->val = $val;
    }

    function interpret(Context $context)
    {
        if (!is_null($this->val)) {
            $context->replace($this, $this->val);
            $this->val = null;
        }
    }

    function setValue($value)
    {
        $this->val = $value;
    }

    function getKey()
    {
        return $this->name;
    }
}

// end previous

//操作符基类
abstract class OperatorExpression extends Expression
{
    protected $l_op;    #左边表达式对象
    protected $r_op;    #右边表达式对象

    function __construct(Expression $l_op, Expression $r_op)
    {
        $this->l_op = $l_op;
        $this->r_op = $r_op;
    }

    function interpret(Context $context)
    {
        $this->l_op->interpret($context);
        $this->r_op->interpret($context);
        $result_l = $context->lookup($this->l_op);
        $result_r = $context->lookup($this->r_op);
        $this->doInterpret($context, $result_l, $result_r);
    }

    //实际操作方法
    protected abstract function doInterpret(Context $context, $result_l, $result_r);
}


class EqualsExpression extends OperatorExpression
{
    //实现了具体操作方法
    protected function doInterpret(Context $context, $result_l, $result_r)
    {
        $context->replace($this, $result_l == $result_r);     #把操作结果存储
    }
}

class BooleanOrExpression extends OperatorExpression
{
    protected function doInterpret(Context $context, $result_l, $result_r)
    {
        $context->replace($this, $result_l || $result_r);
    }
}

class BooleanAndExpression extends OperatorExpression
{
    protected function doInterpret(Context $context, $result_l, $result_r)
    {
        $context->replace($this, $result_l && $result_r);
    }
}

$context = new Context();
$input = new VariableExpression('input');     #即值为null
$statement = new BooleanOrExpression(
//EqualsExpression是判断两个形参对象的值是否相等，$input暂时未被赋值
    new EqualsExpression($input, new LiteralExpression('four')),
    new EqualsExpression($input, new LiteralExpression('4'))
);

foreach (array("four", "4", "52") as $val) {
    $input->setValue($val);
    print "$val:\n";
    /**
     * 注意：这儿的流程会执行BooleanOrExpression的interpret()，但又里面会先执行
     * 两个形参EqualsExpression的interpret()方法，继而会进一步先执行$input 和 LiteralExpression
     * 的interpret()方法，然后每一个的doInterpret()，存储 键为Expression::keycount+1
     * (每new Expression,获取到keycount都会不同，因为是类的变量)
     * 相应的结果作为值，存储在Context::expressionstore中
     */
    $statement->interpret($context);
    if ($context->lookup($statement)) {
        print "top marks\n\n";
    } else {
        print "dunce hat on\n\n";
    }
}




```

## 迭代器模式

```php
<?php
/**
 * 迭代器模式
 * 说明：在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素
 *      相对于传统的编程模式，迭代器模式可以隐藏遍历元素的所需的操作。
 * 思想：要实现迭代器，必须继承原生的Iterator接口，且实现rewind()、valid()、current()
 * next()、key()五个方法
 */
class AllUser implements \Iterator
{
    protected $data = array(); //存储要迭代的数据数组
    protected $index; //存储迭代当前位置下标

    function __construct()
    {
        $this->data = array(
            ["id"=>1,"name"=>"neo"],
            ["id"=>2,"name"=>"hehe"]
        );
    }

    /**
     * 迭代调用第一步 ：重置迭代器
     */
    public function rewind()
    {
        echo "one\n";
        $this->index = 0;
    }

    /**
     * 迭代调用第二步 ：验证是否还有下一个
     * @return boolean
     */
    public function valid()
    {
        echo "two\n";
        return $this->index < count($this->data);
    }

    /**
     * 迭代调用第三步 ：返回当前的元素
     */
    public function current()
    {
        echo "three\n";
        return $this->data[$this->index];
    }

    /**
     * 迭代调用第四步 ：返回当前元素的下标
     */
    public function key()
    {
        echo "four\n";
        return $this->index;
    }

    /**
     * 迭代调用第五步 ：返回下一个元素的下标，这一步是在foreach迭代一次后，执行的
     * 类似于步骤 123,next,23,23
     */
    public function next()
    {
        echo "five\n";
        $this->index ++;
    }
}

$users = new AllUser;
foreach ($users as $key => $value) {
    echo "\n";
}

```

## 调停者模式

```php
<?php
/**
 * 参考：<https://www.cnblogs.com/V1haoge/p/6518603.html>
 * 参考：<https://www.cnblogs.com/not2/p/10844226.html>
 * 调停者模式：将各个类之间的互相调用耦合，转变为所有请求都向调停者请求
 *
 * 一般问题：系统内部经常会出现多个类互相耦合，形成网状结构。任意一个类发生改变，
 * 所有调用者也会受到影响，造成阅读和维护困难。
 * 引入调停者模式的意图是将一对多转化成一对一，降低整个系统的交互复杂度。
 *
 * 优点：集中控制交互，将一对多转化成一对一，降低了耦合度
 * 缺点：中介类会庞大，变得复杂难以维护
 * 总结：调停者模式是一种行为型设计模式，是对交互的封装。它的目的在于降低系统内部各组件之间的耦合，
 * 集中控制交互，所以它是内向闭合的，要与外观模式的外向公开特性区分。同时，中介类的内部设计要有条理，
 * 规范注释，避免随着系统需求不断升级而变得过于臃肿，难以维护。
 */
// 调停者接口
interface Mediator
{
    public function change(Staff $staff, $from, $msg);
}

class Manager implements Mediator
{
    public function change(Staff $staff, $from, $msg)
    {
        echo "manager receive from {$from}, msg is {$msg}\n\r";
        echo "manager forwards {$msg} to {$staff->name}\n\r";
        $staff->callByMediator($from, $msg);            // 控制反转了
    }
}

abstract class Staff
{
    public $name;
    private $mediator;

    public function __construct($mediator, $name)
    {
        $this->name = $name;
        $this->mediator = $mediator;
    }

    // 被调停者调用的方法，用于控制反转
    public function callByMediator($from, $msg)
    {
        echo "{$this->name} receive {$msg} from {$from}\n\r";
    }

    // 调用调停者
    public function callMediator($staff, $msg)
    {
        echo "{$this->name} call mediator to coordinate {$staff->name} {$msg}\n\r";
        $this->mediator->change($staff, $this->name, $msg);
    }
}

// 职员01
class Staff01 extends Staff
{
}

// 职员02
class Staff02 extends Staff
{
}

// 职员03
class Staff03 extends Staff
{
}

$mediator = new Manager();
$neo = new Staff01($mediator, "neo");
$lydia = new Staff02($mediator, "lydia");
$jordan = new Staff03($mediator, "jordan");
// neo给jordan发需求
$neo->callMediator($jordan, 'just do it');
$lydia->callMediator($neo, 'thanks!');

```

## 观察者模式

```php
<?php
/**
 * 观察者模式
 * 说明：当一个对象状态发生改变时，依赖它的对象全部会收到通知(其实是执行所有观察者对象
 *      的一些方法,例如下例执行的是是update()方法)，并自动更新
 * 思想：将实例储存起来，然后批量调用他们的方法
 * 示例：一个事件发生后，要执行一连串的更新操作。传统的编程方式，就是在事件的代码
 * 之后直接加入处理逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合
 * 的，侵入式的，增加新的逻辑需要修改事件主体代码
 * 观察者模式实现了低耦合，非侵入式的通知与更新机制
 *
 * 为啥叫观察者模式？
 * 事件发生，大家围观(执行相同动作)
 */

/**
* 事件发生者
*/
abstract class EventGenerator
{
    protected $observers = array();     //存储观察者对象

    function addObserver(Observer $observer){
        $this->observers[] = $observer;
    }

    function notify(){
        foreach ($this->observers as $observer) {
            $observer->update();
        }
    }
    
    abstract function trigger();
    
}

/**
* 事件
*/
class Event extends EventGenerator
{
    /**
    *事件触发
    */
    public function trigger()
    {
        echo "It happened\n";
        $this->notify();        #通知所有观察者
    }
}

/**
* 观察者，即被通知对象
*/
interface Observer{

    function update();
    
}


/**
* 观察者1
*/
class Observer1 implements Observer
{
    
    public function update()
    {
        echo "I am Observer1, I received the event message\n";
    }
}

/**
* 观察者2
*/
class Observer2 implements Observer
{
    
    public function update()
    {
        echo "I am Observer2, I received the event message\n";
    }
}

$event = new Event;
$event->addObserver(new Observer1);     //添加观察者
$event->addObserver(new Observer2);
$event->trigger();





```

## 访问者模式

```php
<?php
/**
*概念：
* 访问者模式实际上是让外部类能够获取树形结构的每个节点的对象，对每个对象进行操作的模式，
* 他能让我们在不改动原有树形结构的基础上扩展功能。比如统计等等
*
*在这种模式下，必须有的几个要素：
*1： 具体的元素对象， 访问者实际要访问的位置（即节点）
*2： 稳定的树形结构， 每个节点都是一个元素对象， 一般在组合模式下比较多， 他提供了让访问者能够进行访问的实际位置（即访问者访问的是具体的树形结构的某个节点的实例化对象）：
*3： 访问者接口，这里定义了访问者的接口方法 ， 这是个在每个节点都会用到的方法，用以节点处引用访问者，从而使得访问者能够访问当前节点
*4： 访问者的具体实现. 继承了访问者接口，以实现接口方法
*（还可以加一个要素： 元素的接口,对应 要点1）
*
* 访问者与观察者的异同：
* 同：都是反向调用对象（访问者或观察者对象）方法
* 异：
*     访问者模式，反向调用(参数是对象)储存对象的同一方法名，方法内容不同，如方法里再调用不同积分方法
*     观察者模式，反向调用(参数是对象)储存对象的同一个方法名，方法内容基本相同，如update()；
* 用途：要给不同用户组的用户添加不同的积分。
*/
//定义元素接口
abstract class User
{
    public function getPoint()
    {
        return rand(); //该数据应该由数据库中读取，这里就直接模拟某个值了
    }

    //这里的accept方法用于把访问者引入，在这个方法里，($visitor)访问者可以通过User类获取需要的数据进而进行相应的操作
    abstract public function accept(UserVisitor $vitor);

}

//实现元素接口
class VipUser extends User
{
    //这里的getPoint()具体实现就由接口中实现了

    //在这里就把当前对象传递给了visitor 访问者， 在访问者类的visitVip方法中就能根据$this获取必要的数据进行相应的操作
    public function accept(UserVisitor $vitor)
    {
        $vitor->visitVip($this);    //这里反转控制，与观察者模式不同
    }
}

class NormalUser extends User
{
    //同上的getPoint()具体实现就由接口中实现了

    //同VipUser类中的accept
    public function accept(UserVisitor $vitor)
    {
        $vitor->visitNormal($this);
    }
}

//定义访问者接口
abstract class UserVisitor
{
    //访问者必须要实现的访问不同用户的接口方法
    abstract public function visitVip(User $user);
    abstract public function visitNormal(User $user);
}

//积分操作的访问者实现，关键点：这里以后可以扩展功能，如MoneyActVisitor等类
class PointActVisitor extends UserVisitor
{
    public function visitVip(User $user)
    {
        echo "Vip用户+10分\n";     #其实这里可以调用形参$user中的方法
    }

    public function visitNormal(User $user)
    {
        echo "Normal用户+5分\n";
    }
}

//用户的树形结构
class Users
{
    protected $users;
    public function addUser(User $user)
    {
        $this->users[] = $user;
    }

    //让所有的用户都能被访问者访问
    public function handleVisitor(UserVisitor $visitor) // 与观察者模式的区别在于这里，注入的反转控制实例
    {
        foreach ($this->users as $user) {
            $user->accept($visitor);        // 到这里还跟观察者模式一样，只是accept($visitor)里面形成了反转
        }
    }
}

$pointVisitor = new PointActVisitor();

$users = new Users();
$users->addUser(new VipUser()); //添加新用户
$users->addUser(new NormalUser());
$users->addUser(new NormalUser());

$users->handleVisitor($pointVisitor); //执行PointActVisitor访问者的操作

//结果
// Vip用户+10分 
// Normal用户+5分
// Normal用户+5分

```

## 代理模式

```php
<?php
/**
 * 代理模式
 * 说明：在客户端与实体之间建立一个代理对象(proxy)，客户端对实体进行操作全部委派给代理
 * 对象，隐藏实体的具体实现细节。
 * Proxy还可以与业务代码分离，部署到另外的服务器。业务代码中通过PRC来委派任务。
 * 其实就是做了一层简单的封装；
 */

/**
 * 规范
 */
interface IUserProxy
{
    public function getUserName($id);
    public function setUserName($id, $name);
}

/**
 * 实际操作
 */
class Proxy implements IUserProxy
{
    public function getUserName($id)
    {
        $db = Factory::getDatabase('slave');
        $db->query("select name from user where id = $id limit 1");
    }

    public function setUserName($id, $name)
    {
        $db = Factory::getDatabase('master');
        $db->query("update user set name = $name where id = 1 limit 1");
    }
}

$proxy = new Proxy;
$proxy->getUserName('1');
$proxy->setUserName('1', 'neo');


```

## 数据对象映射模式

```php
<?php
/**
 * 数据对象映射模式
 * 说明：是将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作。
 * 应用：在代码中实现数据对象映射模式，我们将实现一个ORM类，将复杂的SQL语句映
 * 射成对象属性的操作；
 * 结合使用数据对象映射模式，工厂模式，注册模式(这里就是简单应用，暂时没写代码)
 */


/**
* 以User表为例，User表中有id、name、mobile、regtime四个字段
*/
class ClassName extends AnotherClass
{
    public $id;
    public $name;
    public $mobile;
    public $regtime;

    protected $db;

    function __construct($id)
    {
        $this->db = new MySQLi();
        $this->db->connect('127.0.0.1','root','root','test');
        $this->db->query("select * from user where id = {$id}");
        $data = $res->fetch_assoc();
        $this->id = $data['id'];
        $this->name = $data['name'];
        $this->mobile = $data['mobile'];
        $this->regtime = $data['regtime'];
    }


    function __destruct()
    {
        $this->db->query("update user set name = '{$this->name}',mobile = '{$this->mobile}',
            regtime = '{$this->regtime}' where id = '{$this->id}' limit 1");
    }
}


```

## 注册树模式

```php
<?php
/**
 * 注册树模式
 * 说明：将注册的对象存储在类的静态变量里，可以随时获取，感觉有点像服务定位，
 * Yii的服务定位还实现了按需分配；
 * 优点：可以统一获取管理注册后的对象，方便获取与删除，当然单例也可以放入注册树
 */
class Register
{
    protected static $objects; #存储已经注册过的对象；
    protected static $definations; #这里只是提示，Yii中存储的类的定义以及依赖关系，并且实现了按需分配

    /**
     * 获取已经注册过的对象
     * @param  string $alias 对应对象的键
     * @return 返回具体的对象
     */
    public static function get($alias)
    {
        return self::$objects[$alias];
    }

    /**
     * 获取已经注册过的对象
     * @param  string $alias 对应对象的键
     * @return 返回具体的对象
     */
    public static function set($alias, $obj)
    {
        return self::$objects[$alias];
    }
}




```

## 单例模式

```php
<?php
/**
 * 单例模式
 * 说明：单例模式，是指在整个项目中只能有一个对象
 * 优点：避免资源浪费。
 */
class Singleton
{
    private $props = array(); #存储属性键值对
    private static $instance; #存储单例对象

    //这里是重点：构造函数私有化
    private function __construct()
    {}

    public static function getInstance()
    {
        if (self::$instance == NULL) {
            self::$instance = new self;
        }
        return self::$instance;
    }

    public function setProperty($key, $val)
    {
        $this->props[$key] = $val;
    }

    public function getProperty($key)
    {
        return $this->props[$key];
    }
}

$pref = Singleton::getInstance();
$pref->setProperty("name", "matt");
// remove the reference，从这里可以看出方法通过return返回的值是与等号的变量建立的引用
// 即这里只是删除引用的变量而已，对引用并无影响
unset($pref);

$pref2 = Singleton::getInstance();
print $pref2->getProperty("name") . "\n"; // 值还在

```

## 策略模式

```php
<?php
/**
 * 策略模式
 * 说明：将一组特定的行为和算法封装成类，以适应某些特定上下文环境。
 * 应用举例：假如一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，
 * 并且所有广告位展示不同的广告。
 * 说明：策略模式可以实现Ioc、依赖倒置、控制反转
 */

/**
* 用户策略接口
*/
interface UserStrategy
{
	function showAd();			//展示广告
	function showCategory();	//展示商品分类
}

/**
* 女装策略
*/
class FemaleUserStrategy implements UserStrategy
{
	
	public function showAd()
	{
		echo "female ad\n";
	}

	public function showCategory()
	{
		echo "female category\n";
	}

}

/**
* 男装策略
*/
class maleUserStrategy implements UserStrategy
{
	
	public function showAd()
	{
		echo "male ad\n";
	}

	public function showCategory()
	{
		echo "male category\n";
	}

}

/**
* 展示页面
*/
class Show
{
	
	protected	$strategy; 		//存储策略对象

	public function Index()
	{
		$this->strategy->showAd();
		$this->strategy->showCategory();
	}

	public function setStrategy(UserStrategy $strategy)
	{
		$this->strategy = $strategy;
	}
}

header("content-type:text/html;charset=utf-8");
$show = new Show;
$show->setStrategy(new FemaleUserStrategy);
$show->Index();


```
